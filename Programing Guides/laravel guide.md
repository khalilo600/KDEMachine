# Laravel Guide: Comprehensive Learning Outline

This guide provides a structured overview of Laravel, a popular open-source PHP web framework. It covers fundamental concepts, routing, controllers, templating with Blade, database interaction with Eloquent ORM, forms, authentication, advanced features, testing, and deployment best practices.

---

## I. Getting Started and Core Concepts

### A. What is Laravel?

Laravel is a free, open-source PHP web framework created by Taylor Otwell and intended for the development of web applications following the model-view-controller (MVC) architectural pattern. It aims to make the development process a pleasing one for developers without sacrificing application functionality.

*   **MVC Architecture:** Separates application logic into Model (data), View (UI), and Controller (logic).
*   **Elegant Syntax:** Known for its expressive and readable code.
*   **Rich Features:** Provides many out-of-the-box features for common web development tasks.

### B. Why Use Laravel?

*   **Rapid Development:** Speeds up development with pre-built functionalities and tools.
*   **Scalability:** Designed to build applications that can scale.
*   **Security:** Built-in features for common web vulnerabilities (CSRF, XSS, SQL injection).
*   **Large Ecosystem:** Extensive official packages, a vast community, and third-party libraries.
*   **Excellent Documentation:** Comprehensive and well-maintained documentation.
*   **Artisan CLI:** Powerful command-line interface for various development tasks.

### C. Installation and Setup (Composer, Laravel Installer, Docker/Sail)

Laravel utilizes Composer to manage its dependencies.

1.  **Composer:** Ensure Composer is installed globally.

    ```bash
    composer global require laravel/installer
    ```

2.  **Laravel Installer:**

    ```bash
    laravel new example-app
    cd example-app
    php artisan serve
    ```

3.  **Composer `create-project`:**

    ```bash
    composer create-project laravel/laravel example-app
    cd example-app
    php artisan serve
    ```

4.  **Docker with Laravel Sail:** Laravel Sail is a light-weight command-line interface for interacting with Laravel's default Docker development environment.

    ```bash
    curl -s "https://laravel.build/example-app" | bash
    cd example-app
    ./vendor/bin/sail up
    ./vendor/bin/sail artisan serve
    ```

### D. Directory Structure

Laravel's directory structure is designed to be intuitive and scalable.

*   **`app/`:** Contains the core code of your application (Models, Controllers, Providers, etc.).
*   **`bootstrap/`:** Contains the `app.php` file that bootstraps the framework.
*   **`config/`:** Contains all of your application's configuration files.
*   **`database/`:** Contains your database migrations, model factories, and seeders.
*   **`public/`:** The web server's document root. Contains `index.php` and your compiled assets.
*   **`resources/`:** Contains your views, language files, and uncompiled assets (CSS, JavaScript).
*   **`routes/`:** Contains all of your application's route definitions.
*   **`storage/`:** Contains compiled Blade templates, file-based sessions, file caches, and other files generated by the framework.
*   **`tests/`:** Contains your automated tests.
*   **`vendor/`:** Contains your Composer dependencies.

### E. Configuration (`.env` file)

Laravel uses environment variables to manage configuration that varies between environments (development, production). These are stored in a `.env` file in the project root.

```dotenv
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:YOUR_APP_KEY_HERE
APP_DEBUG=true
APP_URL=http://localhost

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=laravel
DB_USERNAME=root
DB_PASSWORD=

# ... other configurations
```

### F. Request Lifecycle

1.  **`public/index.php`:** All requests are directed here.
2.  **HTTP Kernel:** Handles the request, runs global middleware.
3.  **Service Providers:** Register and boot various framework services.
4.  **Routing:** Matches the incoming request to a defined route.
5.  **Middleware:** Route-specific middleware are executed.
6.  **Controller/Closure:** The route's action is executed.
7.  **Response:** A response is generated and sent back through the HTTP kernel.

---

## II. Routing

Laravel's routing system allows you to define how your application responds to specific URLs.

### A. Basic Routing (`Route::get`, `post`, `put`, `delete`)

Routes are defined in `routes/web.php` (for web interfaces) or `routes/api.php` (for stateless APIs).

```php
// routes/web.php

use Illuminate\Support\Facades\Route;

Route::get('/', function () {
    return view('welcome');
});

Route::post('/submit', function () {
    return 'Form submitted!';
});

Route::put('/users/{id}', function ($id) {
    return 'Update user ' . $id;
});

Route::delete('/users/{id}', function ($id) {
    return 'Delete user ' . $id;
});
```

### B. Route Parameters

Capture segments of the URI.

```php
Route::get('/users/{id}', function ($id) {
    return 'User ID: ' . $id;
});

// Optional parameter
Route::get('/posts/{id?}', function ($id = null) {
    return 'Post ID: ' . ($id ?? 'No ID');
});

// Regular Expression Constraints
Route::get('/products/{id}', function ($id) {
    return 'Product ID: ' . $id;
})->where('id', '[0-9]+');
```

### C. Named Routes

Assigning names to routes allows you to generate URLs or redirects to them without hardcoding the URI.

```php
Route::get('/profile', function () {
    return 'User Profile';
})->name('profile');

// Generating URL: route('profile')
// Redirecting: redirect()->route('profile')
```

### D. Route Groups (Middleware, Prefix, Namespace)

Group routes with shared attributes.

```php
Route::middleware(['auth'])->group(function () {
    Route::get('/dashboard', function () {
        return 'Dashboard';
    });
    Route::get('/settings', function () {
        return 'Settings';
    });
});

Route::prefix('admin')->group(function () {
    Route::get('/users', function () {
        return 'Admin Users';
    });
});
```

### E. View Routes

Directly return a view without a controller.

```php
Route::view('/welcome', 'welcome', ['name' => 'Guest']);
```

### F. Redirect Routes

Redirect to another URI.

```php
Route::redirect('/here', '/there', 301);
```

---

## III. Controllers

Controllers group related request handling logic into a single class.

### A. Creating Controllers (`php artisan make:controller`)

```bash
php artisan make:controller UserController
```

```php
// app/Http/Controllers/UserController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class UserController extends Controller
{
    public function index()
    {
        return 'List of users';
    }

    public function show($id)
    {
        return 'Display user ' . $id;
    }
}
```

### B. Controller Actions

Link routes to controller methods.

```php
// routes/web.php
use App\Http\Controllers\UserController;

Route::get('/users', [UserController::class, 'index']);
Route::get('/users/{id}', [UserController::class, 'show']);
```

### C. Resource Controllers

Generate a full set of CRUD routes and controller methods with a single declaration.

```bash
php artisan make:controller PostController --resource
```

```php
// routes/web.php
use App\Http\Controllers\PostController;

Route::resource('posts', PostController::class);
// This creates routes for index, create, store, show, edit, update, destroy
```

### D. Single Action Controllers

For controllers that only handle a single action.

```bash
php artisan make:controller ShowProfileController --invokable
```

```php
// app/Http/Controllers/ShowProfileController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Models\User;

class ShowProfileController extends Controller
{
    /**
     * Handle the incoming request.
     */
    public function __invoke(User $user)
    {
        return view('user.profile', ['user' => $user]);
    }
}
```

```php
// routes/web.php
use App\Http\Controllers\ShowProfileController;

Route::get('/user/{user}', ShowProfileController::class);
```

---

## IV. Views and Blade Templates

Views contain the HTML served by your application. Blade is Laravel's powerful templating engine.

### A. Creating Views

Views are typically stored in `resources/views`.

```html
<!-- resources/views/greeting.blade.php -->
<h1>Hello, {{ $name }}!</h1>
```

### B. Passing Data to Views

```php
// routes/web.php
Route::get('/greeting', function () {
    return view('greeting', ['name' => 'Laravel']);
});

// Or using compact()
Route::get('/welcome', function () {
    $name = 'John';
    return view('welcome', compact('name'));
});
```

### C. Blade Syntax (Echoing, Control Structures, Loops)

*   **Echoing Data:** `{{ $variable }}` (automatically escaped) or `{!! $variable !!}` (unescaped).
*   **Control Structures:**
    *   `@if`, `@elseif`, `@else`, `@endif`
    *   `@unless`, `@endunless`
    *   `@isset`, `@endisset`
    *   `@empty`, `@endempty`
*   **Loops:**
    *   `@for`, `@endfor`
    *   `@foreach`, `@endforeach`
    *   `@while`, `@endwhile`

```html
<!-- resources/views/dashboard.blade.php -->
@if (Auth::check())
    <p>Welcome, {{ Auth::user()->name }}!</p>
@else
    <p>Please log in.</p>
@endif

@foreach ($users as $user)
    <li>{{ $user->name }}</li>
@endforeach
```

### D. Template Inheritance (`@extends`, `@section`, `@yield`)

Define a master layout and extend it in child views.

```html
<!-- resources/views/layouts/app.blade.php (Master Layout) -->
<!DOCTYPE html>
<html>
<head>
    <title>App Name - @yield('title')</title>
</head>
<body>
    @section('sidebar')
        This is the master sidebar.
    @show

    <div class="container">
        @yield('content')
    </div>
</body>
</html>
```

```html
<!-- resources/views/child.blade.php (Child View) -->
@extends('layouts.app')

@section('title', 'Page Title')

@section('sidebar')
    @parent {{-- Keep master sidebar content --}}
    <p>This is appended to the master sidebar.</p>
@endsection

@section('content')
    <p>This is my body content.</p>
@endsection
```

### E. Components and Slots

Reusable pieces of UI.

```html
<!-- resources/views/components/alert.blade.php -->
<div class="alert alert-{{ $type ?? 'info' }}">
    {{ $slot }}
</div>
```

```html
<!-- Usage in another view -->
<x-alert type="success">
    <strong>Success!</strong> Your operation was successful.
</x-alert>

<x-alert>
    This is a default info alert.
</x-alert>
```

---

## V. Database Interaction (Eloquent ORM)

Eloquent is Laravel's powerful Object-Relational Mapper (ORM), providing an ActiveRecord implementation for working with your database.

### A. Configuration

Database connection settings are in `config/database.php` and typically configured via the `.env` file.

```dotenv
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=your_database_name
DB_USERNAME=your_username
DB_PASSWORD=your_password
```

### B. Migrations (`php artisan make:migration`, `migrate`)

Migrations are like version control for your database, allowing you to define and modify your database schema using PHP code.

```bash
php artisan make:migration create_users_table
```

```php
// database/migrations/YYYY_MM_DD_HHMMSS_create_users_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('users');
    }
};
```

Run migrations:

```bash
php artisan migrate
```

### C. Models (`php artisan make:model`)

Models are classes that represent tables in your database and allow you to interact with them using Eloquent.

```bash
php artisan make:model Post
```

```php
// app/Models/Post.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Post extends Model
{
    use HasFactory;

    // Define fillable fields for mass assignment
    protected $fillable = ['title', 'body', 'user_id'];

    // Define relationship with User model
    public function user()
    {
        return $this->belongsTo(User::class);
    }
}
```

### D. Basic CRUD Operations (Create, Read, Update, Delete)

```php
use App\Models\Post;

// Create
$post = Post::create([
    'title' => 'My First Post',
    'body' => 'This is the content of my first post.',
    'user_id' => 1,
]);

// Read (Retrieve)
$posts = Post::all(); // Get all posts
$post = Post::find(1); // Find post by primary key
$post = Post::where('title', 'My First Post')->first(); // Find by attribute

// Update
$post = Post::find(1);
$post->title = 'Updated Title';
$post->save();

// Or mass update
Post::where('user_id', 1)->update(['status' => 'published']);

// Delete
$post = Post::find(1);
$post->delete();

// Or mass delete
Post::where('status', 'draft')->delete();
```

### E. Relationships (One-to-One, One-to-Many, Many-to-Many)

Eloquent makes it easy to define relationships between models.

*   **One-to-One:** `hasOne`, `belongsTo`
*   **One-to-Many:** `hasMany`, `belongsTo`
*   **Many-to-Many:** `belongsToMany`

```php
// app/Models/User.php
class User extends Model
{
    public function posts()
    {
        return $this->hasMany(Post::class);
    }
}

// app/Models/Post.php
class Post extends Model
{
    public function user()
    {
        return $this->belongsTo(User::class);
    }
}

// Usage
$user = User::find(1);
foreach ($user->posts as $post) {
    echo $post->title;
}
echo $post->user->name;
```

### F. Seeders (`php artisan make:seeder`, `db:seed`)

Seeders are used to populate your database with dummy data for testing or initial setup.

```bash
php artisan make:seeder UserSeeder
```

```php
// database/seeders/UserSeeder.php
<?php

namespace Database\Seeders;

use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;
use App\Models\User; // Import your User model

class UserSeeder extends Seeder
{
    public function run(): void
    {
        User::factory()->count(10)->create(); // Create 10 users using a factory
    }
}
```

Run seeders:

```bash
php artisan db:seed --class=UserSeeder
php artisan migrate:fresh --seed // Fresh migration and run all seeders
```

### G. Factories (`php artisan make:factory`)

Factories provide a convenient way to generate large amounts of dummy data for your models.

```bash
php artisan make:factory PostFactory --model=Post
```

```php
// database/factories/PostFactory.php
<?php

namespace Database\Factories;

use App\Models\User;
use Illuminate\Database\Eloquent\Factories\Factory;

class PostFactory extends Factory
{
    public function definition(): array
    {
        return [
            'user_id' => User::factory(), // Create a user for each post
            'title' => $this->faker->sentence(),
            'body' => $this->faker->paragraphs(3, true),
        ];
    }
}
```

---

## VI. Forms and Validation

Laravel provides robust tools for handling form submissions and validating data.

### A. Form Requests (`php artisan make:request`)

Dedicated classes for handling validation logic.

```bash
php artisan make:request StorePostRequest
```

```php
// app/Http/Requests/StorePostRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StorePostRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true; // Set to true if all users can make this request
    }

    public function rules(): array
    {
        return [
            'title' => ['required', 'string', 'max:255'],
            'body' => ['required', 'string'],
            'user_id' => ['required', 'exists:users,id'],
        ];
    }
}
```

### B. Validation Rules

Laravel offers a wide array of validation rules.

```php
// In a controller method
use Illuminate\Http\Request;

public function store(Request $request)
{
    $validated = $request->validate([
        'title' => 'required|unique:posts|max:255',
        'body' => 'required',
    ]);

    // The request is valid, process the data
}
```

### C. Displaying Validation Errors

Errors are automatically available in the `$errors` variable in Blade views.

```html
<!-- resources/views/posts/create.blade.php -->
@if ($errors->any())
    <div class="alert alert-danger">
        <ul>
            @foreach ($errors->all() as $error)
                <li>{{ $error }}</li>
            @endforeach
        </ul>
    </div>
@endif

<form method="POST" action="/posts">
    @csrf {{-- CSRF protection --}}
    <input type="text" name="title" value="{{ old('title') }}">
    @error('title')
        <div class="alert alert-danger">{{ $message }}</div>
    @enderror
    <textarea name="body">{{ old('body') }}</textarea>
    <button type="submit">Submit</button>
</form>
```

### D. Old Input

The `old()` helper function retrieves previously flashed input data, useful for re-populating forms after validation fails.

(See example in Section VI.C)

---

## VII. Authentication and Authorization

Laravel provides robust features for managing user authentication and authorization.

### A. Laravel Breeze/Jetstream (Scaffolding)

Laravel offers starter kits to quickly scaffold authentication features.

*   **Laravel Breeze:** A minimal, simple implementation of all of Laravel's authentication features, including login, registration, password reset, email verification, and password confirmation. Uses Blade templates.

    ```bash
    composer require laravel/breeze --dev
    php artisan breeze:install
    npm install && npm run dev
    php artisan migrate
    ```

*   **Laravel Jetstream:** A more robust starter kit that includes two-factor authentication, API support via Laravel Sanctum, and team management. Offers Livewire/Blade or Inertia/Vue stacks.

    ```bash
    composer require laravel/jetstream
    php artisan jetstream:install livewire # or inertia
    npm install && npm run dev
    php artisan migrate
    ```

### B. Manual Authentication (Guards, Providers)

You can also implement authentication manually using Laravel's authentication system.

*   **Guards:** Define how users are authenticated for each request.
*   **Providers:** Retrieve users from your persistent storage (database, LDAP, etc.).

```php
// In a controller
use Illuminate\Support\Facades\Auth;

public function login(Request $request)
{
    $credentials = $request->validate([
        'email' => ['required', 'email'],
        'password' => ['required'],
    ]);

    if (Auth::attempt($credentials)) {
        $request->session()->regenerate();
        return redirect()->intended('dashboard');
    }

    return back()->withErrors([
        'email' => 'The provided credentials do not match our records.',
    ]);
}
```

### C. Authorization (Gates, Policies)

*   **Gates:** Simple, closure-based authorization checks.

    ```php
    // app/Providers/AuthServiceProvider.php
    use Illuminate\Support\Facades\Gate;

    public function boot(): void
    {
        Gate::define('update-post', function (User $user, Post $post) {
            return $user->id === $post->user_id;
        });
    }

    // Usage in controller
    if (Gate::allows('update-post', $post)) {
        // User can update post
    }
    ```

*   **Policies:** Classes that organize authorization logic for a particular model or resource.

    ```bash
    php artisan make:policy PostPolicy --model=Post
    ```

    ```php
    // app/Policies/PostPolicy.php
    <?php

    namespace App\Policies;

    use App\Models\User;
    use App\Models\Post;

    class PostPolicy
    {
        public function update(User $user, Post $post): bool
        {
            return $user->id === $post->user_id;
        }
    }
    ```

    ```php
    // Usage in controller
    public function update(Request $request, Post $post)
    {
        $this->authorize('update', $post); // Throws 403 if not authorized
        // Update the post
    }

    // Usage in Blade
    @can('update', $post)
        <button>Edit Post</button>
    @endcan
    ```

---

## VIII. Advanced Features

### A. Middleware

Middleware provides a convenient mechanism for filtering HTTP requests entering your application.

```bash
php artisan make:middleware CheckAge
```

```php
// app/Http/Middleware/CheckAge.php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class CheckAge
{
    public function handle(Request $request, Closure $next): Response
    {
        if ($request->age < 18) {
            return redirect('home');
        }
        return $next($request);
    }
}
```

Register middleware in `app/Http/Kernel.php`.

```php
// routes/web.php
Route::get('/adults-only', function () {
    return 'Welcome, adult!';
})->middleware('checkAge');
```

### B. Service Providers and Service Container

*   **Service Container:** A powerful tool for managing class dependencies and performing dependency injection.
*   **Service Providers:** The central place for all Laravel application bootstrapping. They register services, bind interfaces to implementations, and more.

### C. Artisan Console

Laravel's command-line interface provides a number of helpful commands for building your application.

```bash
php artisan list          # List all commands
php artisan make:model    # Create a new Eloquent model
php artisan migrate       # Run database migrations
php artisan tinker        # Interact with your application from the command line
php artisan route:list    # List all registered routes
```

### D. Queues

Laravel's queue service provides a unified API across a variety of different queue backends (database, Redis, Amazon SQS, etc.).

```bash
php artisan make:job ProcessPodcast
```

```php
// app/Jobs/ProcessPodcast.php
<?php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class ProcessPodcast implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public $podcast;

    public function __construct(Podcast $podcast)
    {
        $this->podcast = $podcast;
    }

    public function handle(): void
    {
        // Process the podcast
    }
}
```

Dispatch a job: `ProcessPodcast::dispatch($podcast);`

### E. Events and Listeners

Laravel's events provide a simple observer implementation, allowing you to subscribe and listen for various events that occur in your application.

```bash
php artisan make:event OrderShipped
php artisan make:listener SendShipmentNotification --event=OrderShipped
```

### F. Notifications

Laravel's notifications provide a simple, expressive way to send notifications across a variety of delivery channels (mail, SMS, Slack, database).

```bash
php artisan make:notification InvoicePaid
```

### G. File Storage (Filesystem)

Laravel provides a powerful filesystem abstraction thanks to the Flysystem PHP package.

```php
use Illuminate\Support\Facades\Storage;

// Store a file
Storage::put('avatars/1.jpg', $content);

// Retrieve a file
$contents = Storage::get('avatars/1.jpg');

// Store an uploaded file
$path = $request->file('avatar')->store('avatars');
```

### H. Caching

Laravel provides an expressive, unified API for various caching backends.

```php
use Illuminate\Support\Facades\Cache;

$value = Cache::remember('users', $seconds, function () {
    return DB::table('users')->get();
});
```

---

## IX. Testing

Laravel is built with testing in mind and includes support for PHPUnit out of the box.

### A. Unit Tests

Test individual components or methods in isolation.

```bash
php artisan make:test UserTest --unit
```

```php
// tests/Unit/UserTest.php
<?php

namespace Tests\Unit;

use PHPUnit\Framework\TestCase;
use App\Models\User;

class UserTest extends TestCase
{
    public function test_user_can_be_created(): void
    {
        $user = new User();
        $user->name = 'Test User';
        $this->assertEquals('Test User', $user->name);
    }
}
```

### B. Feature Tests

Test larger portions of your application, including how they interact with the database and HTTP requests.

```bash
php artisan make:test PostCreationTest
```

```php
// tests/Feature/PostCreationTest.php
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;
use App\Models\User;
use App\Models\Post;

class PostCreationTest extends TestCase
{
    use RefreshDatabase; // Reset database after each test

    public function test_a_post_can_be_created(): void
    {
        $user = User::factory()->create(); // Create a user
        $this->actingAs($user); // Authenticate the user

        $response = $this->post('/posts', [
            'title' => 'My Test Post',
            'body' => 'This is the body of my test post.',
        ]);

        $response->assertStatus(302); // Redirect after successful creation
        $this->assertDatabaseHas('posts', ['title' => 'My Test Post']);
    }
}
```

### C. Database Testing

Laravel provides helpers for database testing, including `RefreshDatabase` trait to reset the database between tests.

---

## X. Deployment

### A. Server Requirements

*   PHP >= 8.1
*   Composer
*   Web server (Nginx or Apache)
*   Database (MySQL, PostgreSQL, SQLite, SQL Server)

### B. Optimization (Caching, Autoloading)

*   **Configuration Caching:** `php artisan config:cache`
*   **Route Caching:** `php artisan route:cache`
*   **View Caching:** `php artisan view:cache`
*   **Autoloader Optimization:** `composer dump-autoload --optimize`

### C. Environment Configuration

Ensure your `.env` file is correctly configured for the production environment.

```dotenv
APP_ENV=production
APP_DEBUG=false
APP_URL=https://your-domain.com
```

### D. Deployment Platforms (Forge, Vapor, Envoyer)

*   **Laravel Forge:** A server provisioning and deployment service for PHP applications.
*   **Laravel Vapor:** A serverless deployment platform for Laravel, powered by AWS Lambda.
*   **Laravel Envoyer:** A zero-downtime PHP deployer.
*   **Traditional VPS/Cloud:** Deploy to a virtual private server (e.g., DigitalOcean, AWS EC2) with Nginx/Apache and PHP-FPM.
